print("script is running and check if not running then üî¥")
wait(1)
print("dont be sigma because you sigma üßè, Nguwawor loh ya")
wait(1)
print("... VICO HUB (still test) ...")
if _G.Ran == true then return end
wait()
_G.Ran = true
repeat wait() until game:IsLoaded()
local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local speedFactorPingBased
local speedFactor
local Nurysium_Util = loadstring(game:HttpGet("https://raw.githubusercontent.com/flezzpe/Nurysium/main/nurysium_helper.lua"))()
local function getTrainingBall()
	for index, ball in workspace:WaitForChild("TrainingBalls"):GetChildren() do
		if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
			return ball
		end
	end
end
local ismyautoparryspamming
local local_player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local standalone = false
print("[üîÉ]: Vico Hub Is Succesfull Load...")

--//OPTIONS

local originalParryRemote
local originalResolveParryRemote 
local visualizeranalys, autospamanalys, autoparryanalys
local nurysium_Data = nil
local hit_Sound = nil
local closest_Entity = nil
local parry_remote = nil
local aura_Enabled = false
local auto_curve = false
local hit_sound_Enabled = false
local auto_spam = false
local training_mode = false
local hit_effect_Enabled = false
local anti_curve_spam_Enabled = false
local visualize_Enabled = false
local Services = {game:GetService("AdService"),game:GetService("SocialService")}

function initializate(dataFolder_name: string)
    local nurysium_Data = Instance.new('Folder', game:GetService('CoreGui'))
    nurysium_Data.Name = dataFolder_name

    hit_Sound = Instance.new('Sound', nurysium_Data)
    hit_Sound.SoundId = 'rbxassetid://6607204501'
    hit_Sound.Volume = 6
end

local function get_closest_entity(Object)
	task.spawn(function()
		local closest
		local max_distance = math.huge
		for index, entity in workspace.Alive:GetChildren() do
			if entity.Name ~= Players.LocalPlayer.Name then
				local distance = (Object.Position - entity.HumanoidRootPart.Position).Magnitude
				if distance < max_distance then
					closest_Entity = entity
					max_distance = distance
				end
			end
		end
		return closest_Entity
	end)
end

function resolve_parry_Remote()
 local temp_remote = game:GetService("VirtualUser"):WaitForChild("\n\n\n\n\n")

    if not temp_remote then
        return
    end

    if not temp_remote:IsA('RemoteEvent') then
        return
    end

    originalParryRemote = temp_remote
end

resolve_parry_Remote()

function walk_to(position)
	local_player.Character.Humanoid:MoveTo(position)
end
local function get_center()
	for _, object in workspace.Map:GetDescendants() do
		if object.Name == 'BALLSPAWN' then
			return object
		end
	end
end

local aura_table = {
    canParry = true,
    is_Spamming = false,
    parry_Range = 30,
    spam_Range = 0,  
    hit_Count = 0,
    hit_Time = tick(),
    ball_Warping = tick(),
    is_ball_Warping = false,
    last_target = nil,
}

workspace:WaitForChild("Balls").ChildRemoved:Connect(function(child)
	aura_table.hit_Count = 0
	aura_table.is_ball_Warping = false
	aura_table.is_Spamming = false
	aura_table.canParry = true
	aura_table.last_target = nil
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function()
	aura_table.hit_Count += 1

	task.delay(0.185, function()
		aura_table.hit_Count -= 1
	end)
end)

local MauaulSpam -- Declare MauaulSpam globally

function ManualSpam()
    -- Gui to Lua
    -- Version: 3.2
    
    if MauaulSpam then
        MauaulSpam:Destroy()
        MauaulSpam = nil
        return
    end

    MauaulSpam = Instance.new("ScreenGui")
    MauaulSpam.Name = "MauaulSpam"
    MauaulSpam.Parent = game.CoreGui
    MauaulSpam.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    MauaulSpam.ResetOnSpawn = false

    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Parent = MauaulSpam
    Main.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(0.41414836, 0, 0.404336721, 0)
    Main.Size = UDim2.new(0.227479532, 0, 0.191326529, 0)

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = Main

    local IndercantorBlahblah = Instance.new("Frame")
    IndercantorBlahblah.Name = "IndercantorBlahblah"
    IndercantorBlahblah.Parent = Main
    IndercantorBlahblah.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    IndercantorBlahblah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercantorBlahblah.BorderSizePixel = 0
    IndercantorBlahblah.Position = UDim2.new(0.0280000009, 0, 0.0733333305, 0)
    IndercantorBlahblah.Size = UDim2.new(0.0719999969, 0, 0.119999997, 0)

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.CornerRadius = UDim.new(1, 0)
    UICorner_2.Parent = IndercantorBlahblah

    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint.Parent = IndercantorBlahblah

    local PC = Instance.new("TextLabel")
    PC.Name = "PC"
    PC.Parent = Main
    PC.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    PC.BackgroundTransparency = 1.000
    PC.BorderColor3 = Color3.fromRGB(0, 0, 0)
    PC.BorderSizePixel = 0
    PC.Position = UDim2.new(0.547999978, 0, 0.826666653, 0)
    PC.Size = UDim2.new(0.451999992, 0, 0.173333332, 0)
    PC.Font = Enum.Font.Unknown
    PC.Text = "PC: E to spam"
    PC.TextColor3 = Color3.fromRGB(57, 57, 57)
    PC.TextScaled = true
    PC.TextSize = 16.000
    PC.TextWrapped = true

    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint.Parent = PC
    UITextSizeConstraint.MaxTextSize = 16

    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_2.Parent = PC
    UIAspectRatioConstraint_2.AspectRatio = 4.346

    local IndercanotTextBlah = Instance.new("TextButton")
    IndercanotTextBlah.Name = "IndercanotTextBlah"
    IndercanotTextBlah.Parent = Main
    IndercanotTextBlah.Active = false
    IndercanotTextBlah.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.BackgroundTransparency = 1.000
    IndercanotTextBlah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercanotTextBlah.BorderSizePixel = 0
    IndercanotTextBlah.Position = UDim2.new(0.164000005, 0, 0.326666653, 0)
    IndercanotTextBlah.Selectable = false
    IndercanotTextBlah.Size = UDim2.new(0.667999983, 0, 0.346666664, 0)
    IndercanotTextBlah.Font = Enum.Font.GothamBold
    IndercanotTextBlah.Text = "Spam"
    IndercanotTextBlah.TextColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.TextScaled = true
    IndercanotTextBlah.TextSize = 22.000
    IndercanotTextBlah.TextWrapped = true

    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 4)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))}
    UIGradient.Parent = IndercanotTextBlah

    local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_2.Parent = IndercanotTextBlah
    UITextSizeConstraint_2.MaxTextSize = 52

    local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_3.Parent = IndercanotTextBlah
    UIAspectRatioConstraint_3.AspectRatio = 3.212

    local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_4.Parent = Main
    UIAspectRatioConstraint_4.AspectRatio = 1.667

--Properties:

MauaulSpam.Name = "MauaulSpam"
MauaulSpam.Parent = game.CoreGui
MauaulSpam.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
MauaulSpam.ResetOnSpawn = false

Main.Name = "Main"
Main.Parent = MauaulSpam
Main.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Main.BorderColor3 = Color3.fromRGB(0, 0, 0)
Main.BorderSizePixel = 0
Main.Position = UDim2.new(0.41414836, 0, 0.404336721, 0)
Main.Size = UDim2.new(0.227479532, 0, 0.191326529, 0)

UICorner.Parent = Main

IndercantorBlahblah.Name = "IndercantorBlahblah"
IndercantorBlahblah.Parent = Main
IndercantorBlahblah.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
IndercantorBlahblah.BorderColor3 = Color3.fromRGB(0, 0, 0)
IndercantorBlahblah.BorderSizePixel = 0
IndercantorBlahblah.Position = UDim2.new(0.0280000009, 0, 0.0733333305, 0)
IndercantorBlahblah.Size = UDim2.new(0.0719999969, 0, 0.119999997, 0)

UICorner_2.CornerRadius = UDim.new(1, 0)
UICorner_2.Parent = IndercantorBlahblah

UIAspectRatioConstraint.Parent = IndercantorBlahblah

PC.Name = "PC"
PC.Parent = Main
PC.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PC.BackgroundTransparency = 1.000
PC.BorderColor3 = Color3.fromRGB(0, 0, 0)
PC.BorderSizePixel = 0
PC.Position = UDim2.new(0.547999978, 0, 0.826666653, 0)
PC.Size = UDim2.new(0.451999992, 0, 0.173333332, 0)
PC.Font = Enum.Font.Unknown
PC.Text = "E to spam"
PC.TextColor3 = Color3.fromRGB(57, 57, 57)
PC.TextScaled = true
PC.TextSize = 16.000
PC.TextWrapped = true

UITextSizeConstraint.Parent = PC
UITextSizeConstraint.MaxTextSize = 16

UIAspectRatioConstraint_2.Parent = PC
UIAspectRatioConstraint_2.AspectRatio = 4.346

IndercanotTextBlah.Name = "IndercanotTextBlah"
IndercanotTextBlah.Parent = Main
IndercanotTextBlah.Active = false
IndercanotTextBlah.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
IndercanotTextBlah.BackgroundTransparency = 1.000
IndercanotTextBlah.BorderColor3 = Color3.fromRGB(0, 0, 0)
IndercanotTextBlah.BorderSizePixel = 0
IndercanotTextBlah.Position = UDim2.new(0.164000005, 0, 0.326666653, 0)
IndercanotTextBlah.Selectable = false
IndercanotTextBlah.Size = UDim2.new(0.667999983, 0, 0.346666664, 0)
IndercanotTextBlah.Font = Enum.Font.GothamBold
IndercanotTextBlah.Text = "Mode Spam"
IndercanotTextBlah.TextColor3 = Color3.fromRGB(255, 255, 255)
IndercanotTextBlah.TextScaled = true
IndercanotTextBlah.TextSize = 22.000
IndercanotTextBlah.TextWrapped = true

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 4)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))}
UIGradient.Parent = IndercanotTextBlah

UITextSizeConstraint_2.Parent = IndercanotTextBlah
UITextSizeConstraint_2.MaxTextSize = 52

UIAspectRatioConstraint_3.Parent = IndercanotTextBlah
UIAspectRatioConstraint_3.AspectRatio = 3.212

UIAspectRatioConstraint_4.Parent = Main
UIAspectRatioConstraint_4.AspectRatio = 1.667

-- Scripts:

local function HEUNEYP_fake_script() -- IndercanotTextBlah.ColorChangeScript 
	local script = Instance.new('LocalScript', IndercanotTextBlah)

	local button = script.Parent
	local UIGredient = button.UIGradient
	local NeedToChange = script.Parent.Parent.IndercantorBlahblah
	local userInputService = game:GetService("UserInputService")
	local RunService = game:GetService("RunService")

	local green_Color = {
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), 
		ColorSequenceKeypoint.new(0.75, Color3.fromRGB(0, 255, 0)), 
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))
	}

	local red_Color = {
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), 
		ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 0)), 
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))
	}

	local current_Color = red_Color
	local target_Color = green_Color
	local is_Green = false
	local transition = false
	local transition_Time = 1
	local start_Time

	local function startColorTransition()
		transition = true
		start_Time = tick()
	end

	RunService.Heartbeat:Connect(function()
		if transition then
			local elapsed = tick() - start_Time
			local alpha = math.clamp(elapsed / transition_Time, 0, 1)

			local new_Color = {}
			for i = 1, #current_Color do
				local start_Color = current_Color[i].Value
				local end_Color = target_Color[i].Value
				new_Color[i] = ColorSequenceKeypoint.new(
					current_Color[i].Time,
					start_Color:Lerp(end_Color, alpha)
				)
			end

			UIGredient.Color = ColorSequence.new(new_Color)

			if alpha >= 1 then
				transition = false
				current_Color, target_Color = target_Color, current_Color
			end
		end
	end)

	local function toggleColor()
		if not transition then
			is_Green = not is_Green
			if is_Green then
				target_Color = green_Color
				NeedToChange.BackgroundColor3 = Color3.new(0, 1, 0)
			else
				target_Color = red_Color
				NeedToChange.BackgroundColor3 = Color3.new(1, 0, 0)
			end
			startColorTransition()
		end
	end

	button.MouseButton1Click:Connect(toggleColor)

	userInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.E then
			toggleColor()
		end
	end)

	local Services = {game:GetService("AdService"), game:GetService("SocialService")}
	local originalParryRemote = nil

	function resolve_parry_Remote()
        local temp_remote = game:GetService("VirtualUser"):WaitForChild("\n\n\n\n\n")
        if not temp_remote or not temp_remote:IsA('RemoteEvent') then
            return
        end
        originalParryRemote = temp_remote
    end

    resolve_parry_Remote()

	local camera = workspace.CurrentCamera
	local mouse = game.Players.LocalPlayer:GetMouse()

	local function getClosestEntity()
		local closest_Entity = nil
		local shortestDistance = math.huge

		for _, entity in pairs(workspace.Alive:GetChildren()) do
			if entity:IsA("Model") and entity:FindFirstChild("HumanoidRootPart") then
				local screenPoint = camera:WorldToViewportPoint(entity.HumanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

				if distanceToMouse < shortestDistance then
					closest_Entity = entity
					shortestDistance = distanceToMouse
				end
			end
		end

		return closest_Entity
	end

local camera = game:GetService("Workspace").CurrentCamera -- Pastikan kamera terdefinisi
local targetRate = 3000 -- Kecepatan yang diinginkan dalam Hz
local attempts = 0 -- Menghitung upaya untuk membatasi loop pengulangan
local maxAttempts = 15 -- Maksimum upaya untuk mencegah loop tak terhingga

RunService.RenderStepped:Connect(function()
    if originalParryRemote then
        local closest_Entity = getClosestEntity() -- Mendapatkan entitas terdekat

        if camera then
            local cf = camera.CFrame
            local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:GetComponents()

            -- Loop spam
            for count = 1, 2500 do -- Loop untuk spam cepat
                -- Cek apakah is_Green masih true
                if not is_Green then
                    break -- Hentikan spam jika is_Green false
                end
                
                -- Pastikan closest_Entity terdefinisi
                if closest_Entity and closest_Entity:FindFirstChild("HumanoidRootPart") then
                    originalParryRemote:FireServer(
                        0,
                        CFrame.new(x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22),
                        {[closest_Entity.Name] = closest_Entity.HumanoidRootPart.Position},
                        {closest_Entity.HumanoidRootPart.Position.X, closest_Entity.HumanoidRootPart.Position.Y},
                        false
                    )
                else
                    -- Logika cadangan untuk mencari target cadangan
                    local backupTarget = nil
                    for _, potentialTarget in pairs(Players:GetPlayers()) do
                        if potentialTarget ~= Player and potentialTarget.Character and potentialTarget.Character:FindFirstChild("HumanoidRootPart") then
                            backupTarget = potentialTarget
                            break -- Keluar dari loop setelah target cadangan ditemukan
                        end
                    end

                    if backupTarget then
                        local backupPosition = backupTarget.Character.HumanoidRootPart.Position
                        originalParryRemote:FireServer(
                            0,
                            CFrame.new(x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22),
                            {[backupTarget.Name] = backupPosition},
                            {backupPosition.X, backupPosition.Y},
                            false
                        )
                    end
                end
                
                wait(0) -- Atur waktu tunggu untuk spam yang lebih cepat, ubah sesuai kebutuhan
            end
        end
    end
end)
	
	end
coroutine.wrap(HEUNEYP_fake_script)()
local function WWJM_fake_script() -- Main.LocalScript 
	local script = Instance.new('LocalScript', Main)

	local UserInputService = game:GetService("UserInputService")
	
	local gui = script.Parent
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		local newPosition = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)

		local TweenService = game:GetService("TweenService")
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(gui, tweenInfo, {Position = newPosition})
		tween:Play()
	end
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			update(input)
		end
	end)
	
end
coroutine.wrap(WWJM_fake_script)()

end

local function clamp(value, min, max)
	return math.max(min, math.min(max, value))
end
local self = Nurysium_Util.getBall()
	wait(0.1)
	local Visualize = Instance.new("Part",workspace)
	local Visualize1 = Instance.new("Part",workspace)
	wait(0.5)
	Visualize.Color = Color3.new(0, 1, 0)
	Visualize.Material = Enum.Material.ForceField
	Visualize.Transparency = 0.5
	Visualize.Anchored = true
	Visualize.CanCollide = false
	Visualize.CastShadow = false
	Visualize.Shape = Enum.PartType.Ball
	Visualize.Size = Vector3.new(30,30,30)
	Visualize1.Color = Color3.new(1, 0, 0)
	Visualize1.Material = Enum.Material.ForceField
	Visualize1.Transparency = 0.5
	Visualize1.Anchored = true
	Visualize1.CanCollide = false
	Visualize1.CastShadow = false
	Visualize1.Shape = Enum.PartType.Ball
	Visualize1.Size = Vector3.new(aura_table.spam_Range, aura_table.spam_Range, aura_table.spam_Range)

	local Highlight1 = Instance.new("Highlight")
	Highlight1.Parent = Visualize1
	Highlight1.Enabled = true
	Highlight1.FillTransparency = 0
	Highlight1.OutlineColor = Color3.new(1, 1, 1)
	local Highlight = Instance.new("Highlight")
	Highlight.Parent = Visualize
	Highlight.Enabled = true
	Highlight.FillTransparency = 0
	Highlight.OutlineColor = Color3.new(1, 1, 1)
	
task.spawn(function()
	visualizervar = RunService.RenderStepped:Connect(function()
		if visualize_Enabled then
			Visualize.Transparency = 0
			Visualize.Material = Enum.Material.ForceField
			Visualize.Size = Vector3.new(aura_table.parry_Range, aura_table.parry_Range, aura_table.parry_Range)
			Visualize.CFrame = CFrame.new(local_player.Character.PrimaryPart.Position)
			Visualize1.Transparency = 0
			Visualize1.Material = Enum.Material.ForceField
			Visualize1.Size = Vector3.new(aura_table.spam_Range, aura_table.spam_Range, aura_table.spam_Range)
			Visualize1.CFrame = CFrame.new(local_player.Character.PrimaryPart.Position)
		else
			Visualize.Material = Enum.Material.ForceField
			Visualize.Transparency = 1
			Visualize1.Material = Enum.Material.ForceField
			Visualize1.Transparency = 1
		end	
	end)
end)

function getClosestEntityToMouse()
	local closest = nil
	local shortestDistance = math.huge
	local mouse = game.Players.LocalPlayer:GetMouse()

	-- Ensure workspace.Alive exists
	if not workspace:FindFirstChild("Alive") then
		return nil
	end

	-- Loop through all entities
	for _, entity in pairs(workspace.Alive:GetChildren()) do
		if entity:IsA("Model") then
			local humanoidRootPart = entity:FindFirstChild("HumanoidRootPart")
			if humanoidRootPart then
				-- Convert world position to screen position
				local screenPoint = camera:WorldToViewportPoint(humanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

				-- Check if this is the closest entity so far
				if distanceToMouse < shortestDistance then
					closest = entity
					shortestDistance = distanceToMouse
				end
			else
				
			end
		else
			
		end
	end

	-- If no closest entity is found, warn the user
	if not closest then
		
	else
		
	end

	return closest
end

local closest_Entity_To_mouse = nil
local Takentime = tick() - aura_table.hit_Time
RunService.Heartbeat:Connect(function()
Takentime = tick() - aura_table.hit_Time
	task.spawn(function()
		closest_Entity_To_mouse = getClosestEntityToMouse()
	end)
end)


local stopSpamming = false
local spamTask -- Menyimpan ID task untuk kontrol lebih lanjut
local requiredParries = 3  -- Jumlah parry yang dibutuhkan untuk memulai spam
aura_table.hit_Count = aura_table.hit_Count or 0  -- Inisialisasi jumlah hit atau parry

task.spawn(function()
    autospamanalys = RunService.Heartbeat:Connect(function()
        -- Cek apakah auto_spam aktif dan pemain valid
        if not auto_spam or not workspace.Alive:FindFirstChild(local_player.Name) or training_mode then
            -- Reset variabel untuk menghentikan spam
            aura_table.hit_Count = 0
            aura_table.is_Spamming = false
            aura_table.last_target = nil
            ismyautoparryspamming = false
            aura_table.spam_Range = 0
            stopSpamming = true  -- Set flag untuk menghentikan task.spawn

            if spamTask then
                task.cancel(spamTask) -- Hentikan task jika aktif
                spamTask = nil
            end

            return
        end

        if closest_Entity and workspace.Alive:FindFirstChild(closest_Entity.Name) and ((not standalone and aura_table.is_Spamming) or (standalone)) then
            local playerPosition = local_player.Character.PrimaryPart.Position
            local entityPosition = closest_Entity.HumanoidRootPart.Position
            local distanceToEntity = local_player:DistanceFromCharacter(entityPosition)

            -- Cek jarak sebelum memulai spam
            if distanceToEntity <= aura_table.spam_Range then
                -- Increment hit count jika dalam range
                aura_table.hit_Count = aura_table.hit_Count + 1
                
                -- Jika jumlah parry sudah mencapai requiredParries, mulai spam
                if aura_table.hit_Count >= requiredParries then
                    ismyautoparryspamming = true
                    stopSpamming = false  -- Aktifkan spam

                    -- Precompute data untuk meningkatkan performa
                    local cf = camera.CFrame
                    local randomTarget = Vector3.new(math.random(-1000, 1000), math.random(0, 1000), math.random(100, 1000))
                    local targetPosition = closest_Entity_To_mouse.HumanoidRootPart.Position
                    local fireArgs = {
                        {[closest_Entity_To_mouse.Name] = targetPosition},
                        {targetPosition.X, targetPosition.Y}
                    }

                    -- Task.spawn yang akan berhenti jika `stopSpamming` aktif
                    spamTask = task.spawn(function()
                        for count = 1, 500 do
                            -- Cek apakah perlu berhenti
                            if stopSpamming then break end

                            -- Tambahkan jeda antar pengiriman
                            task.wait(0.01)

                            if auto_spam and workspace.Alive:FindFirstChild(local_player.Name) and closest_Entity and workspace.Alive:FindFirstChild(closest_Entity.Name) then
                                if auto_curve then
                                    originalParryRemote:FireServer(0, CFrame.new(cf.Position, randomTarget), unpack(fireArgs))
                                else
                                    originalParryRemote:FireServer(0, cf, unpack(fireArgs))
                                end
                            else
                                -- Jika kondisi gagal, hentikan loop
                                stopSpamming = true
                                break
                            end
                        end
                        -- Reset hit count setelah spam selesai
                        aura_table.hit_Count = 0
                    end)
                end
            else
                -- Reset jika keluar dari range
                aura_table.hit_Count = 0
                ismyautoparryspamming = false
                stopSpamming = true  -- Set untuk menghentikan task.spawn
                if spamTask then
                    task.cancel(spamTask) -- Hentikan task jika keluar dari range
                    spamTask = nil
                end
            end
        else
            -- Reset jika tidak ada entity terdekat
            aura_table.hit_Count = 0
            ismyautoparryspamming = false
            stopSpamming = true  -- Set untuk menghentikan task.spawn
            if spamTask then 
                task.cancel(spamTask) -- Hentikan task jika tidak ada entity terdekat
                spamTask = nil 
            end
        end
    end)

local function linear_predict(a: Vector3, b: Vector3, time_volume: number)
    time_volume = math.clamp(time_volume, 0, 1)
    return a + (b - a) * time_volume
end

autoparryanalys = RunService.Heartbeat:Connect(function()
    if not aura_Enabled or not (workspace.Alive:FindFirstChild(local_player.Name) or training_mode) then
        aura_table.hit_Time = tick() * 10
        aura_table.hit_Count = 0
        aura_table.is_ball_Warping = false
        aura_table.is_Spamming = false
        aura_table.canParry = true
        aura_table.last_target = nil
        return
    end

    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local self

    if training_mode then
        self = getTrainingBall()
    else
        self = Nurysium_Util.getBall()
    end

    if not self then
        aura_table.hit_Time = tick() * 10
        aura_table.hit_Count = 0
        aura_table.is_ball_Warping = false
        aura_table.is_Spamming = false
        aura_table.canParry = true
        aura_table.last_target = nil
        return
    end

    self:GetAttributeChangedSignal('target'):Once(function()
        aura_table.canParry = true
    end)

    if self:GetAttribute('target') ~= local_player.Name or not aura_table.canParry then
        return
    end

    self:GetAttributeChangedSignal('from'):Once(function()
        aura_table.last_target = workspace.Alive:FindFirstChild(self:GetAttribute('from'))
    end)

    get_closest_entity(local_player.Character.PrimaryPart)

    local player_Position = local_player.Character.PrimaryPart.Position
    local ball_Position = self.Position
    local ball_Velocity = self.AssemblyLinearVelocity

    if self:FindFirstChild("zoomies") then
        ball_Velocity = self.zoomies.VectorVelocity
    end

    local ball_Direction = (local_player.Character.PrimaryPart.Position - ball_Position).Unit
    local ball_Distance = (local_player.Character.PrimaryPart.Position - ball_Position).Magnitude
    local ball_Dot = ball_Direction:Dot(ball_Velocity.Unit)
    local ball_Speed = ball_Velocity.Magnitude

    -- Anti-curve mechanism: Adjust for curving velocity
    if ball_Speed < 25 or ball_Velocity.Y > 10 then
        aura_table.hit_Time = tick() * 10
        aura_table.hit_Count = 0
        aura_table.is_ball_Warping = false
        aura_table.is_Spamming = false
        aura_table.can_parry = true
        aura_table.last_target = nil
    end

    local player_Velocity = local_player.Character.HumanoidRootPart.AssemblyLinearVelocity
    local player_isMoving = player_Velocity.Magnitude > 0
    local ball_speed_Limited = math.min(ball_Speed / 1000, 0.1)
    local ball_predicted_Distance = (ball_Distance - ping / 15.3) - (ball_Speed / 3.5)

    local targetPosition = closest_Entity_To_mouse.HumanoidRootPart.Position
    local target_Distance = local_player:DistanceFromCharacter(targetPosition)
    local closest_target_Distance = local_player:DistanceFromCharacter(closest_Entity.HumanoidRootPart.Position)
    local target_distance_Limited = math.min(target_Distance / 10000, 0.1)
    local target_Direction = (local_player.Character.PrimaryPart.Position - closest_Entity.HumanoidRootPart.Position).Unit
    local target_Velocity = closest_Entity.HumanoidRootPart.AssemblyLinearVelocity
    local target_isMoving = target_Velocity.Magnitude > 0
    local target_Dot = target_isMoving and math.max(target_Direction:Dot(target_Velocity.Unit), 0)

-- Menyesuaikan spam Range dengan lebih hati-hati
aura_table.spam_Range = math.max(ping / 10, 10.5) + ball_Speed / 6.15

-- Menghitung faktor kecepatan dan jarak bola
local speedFactor = math.max(3 - (ping / 100), 0.5) -- Pastikan tidak negatif
local speedFactorPingBased = math.max(6.1 - (ping / 100), 0.5) -- Jaga nilai tetap positif

-- Menggunakan ball_Speed dan ball_predicted_Distance untuk menghitung jangkauan parry lebih realistis
local ball_Speed = ball_Speed or 0
local ball_Distance = ball_Distance or 0
local ball_predicted_Distance = ball_predicted_Distance or 0

-- Menyesuaikan jangkauan parry dengan pertimbangan kecepatan bola
aura_table.parry_Range = math.max(math.max(ping, 3.5) + ball_Speed / speedFactor, speedFactorPingBased)

-- Jika ball_Speed lebih tinggi, sesuaikan parry range
if ball_Speed > 20 then
    aura_table.parry_Range = aura_table.parry_Range * 1.1 -- Menyesuaikan range dengan lebih halus untuk bola cepat
end

-- Menggabungkan ball_Direction dan ball_predicted_Distance untuk prediksi jangkauan yang lebih tepat
local predicted_range_adjustment = ball_predicted_Distance * 0.5  -- Sesuaikan faktor berdasarkan kebutuhan
local direction_factor = ball_Direction:Dot(Vector3.new(1, 0, 0)) -- Misalnya, kita asumsikan ball_Direction adalah vektor arah

-- Menyesuaikan range berdasarkan prediksi arah bola
aura_table.parry_Range = aura_table.parry_Range + predicted_range_adjustment * direction_factor

-- Tampilkan hasil jangkauan parry yang disesuaikan
print("Jangkauan Parry yang disesuaikan:", aura_table.parry_Range)

-- Deteksi spam dengan pengaturan lebih realistis
aura_table.is_Spamming = (target_Distance <= aura_table.spam_Range and ball_Distance < 18 and ball_Speed > 8)
                          and ball_Velocity.Y > -50 and ball_Dot > 0.1

-- Menghitung sudut antara arah bola dan kecepatan bola
local velocity_angle = math.abs(math.acos(ball_Direction:Dot(ball_Velocity.Unit)))

-- Menambah logika untuk deteksi bola melengkung dengan sudut yang lebih moderat
if velocity_angle > math.rad(35) then
    aura_table.is_ball_Warping = true
end

-- Penyesuaian lebih halus terhadap waktu parry
local parry_Timing_Adjustment = (ball_Speed / 90) + (ball_Distance / 80) -- Membuat penyesuaian lebih moderat
aura_table.parry_Timing = math.max(aura_table.parry_Range - parry_Timing_Adjustment, 0.6) -- Jangan terlalu pendek

-- Deteksi bola melengkung dengan sensitivitas lebih baik
if ball_Dot < -0.2 then
    aura_table.ball_Warping = tick()
end

-- Task untuk memeriksa apakah bola melengkung
task.spawn(function()
    if (tick() - aura_table.ball_Warping) >= 0.15 + target_distance_Limited - ball_speed_Limited or ball_Distance <= 10 then
        aura_table.is_ball_Warping = false
        return
    end

    if aura_table.last_target then
        if (ball_Position - aura_table.last_target.HumanoidRootPart.Position).Magnitude > 35.5 or target_Distance <= 12 then
            aura_table.is_ball_Warping = false
        end
    end

    -- Deteksi anti-curve yang lebih sensitif
    if ball_Velocity.Y > 10 then
        aura_table.is_ball_Warping = true -- Deteksi bola melengkung berdasarkan kecepatan vertikal
    end
end)

-- Deteksi Parry dengan penyesuaian range dan timing yang lebih tepat
if ball_Distance <= aura_table.parry_Range and not aura_table.is_ball_Warping and ball_Speed > 0 and ball_Dot > 0.1 then
        local cf = camera.CFrame
        local target_X = targetPosition.X
        local target_Y = targetPosition.Y

        if auto_curve then
            originalParryRemote:FireServer(
                0,
                CFrame.new(cf.Position, Vector3.new(math.random(-1000, 1000), math.random(0, 1000), math.random(100, 1000))),
                {[closest_Entity_To_mouse.Name] = targetPosition},
                {target_X, target_Y},
                false
            )
        else
            local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:GetComponents()
            originalParryRemote:FireServer(
                0,
                CFrame.new(x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22),
                {[closest_Entity_To_mouse.Name] = targetPosition},
                {target_X, target_Y},
                false
            )
        end

        aura_table.hit_Count = aura_table.hit_Count + 1
        task.delay(0.55 + (ping / 100), function()
            aura_table.hit_Count = aura_table.hit_Count - 1
        end)

        aura_table.hit_Time = tick()
        aura_table.canParry = false
    end

    task.spawn(function()
        repeat
            RunService.PreRender:Wait()
        until (tick() - aura_table.hit_Time) >= 1
        aura_table.canParry = true
    end)
end)
end)

-- Define a safe disconnect function to avoid errors
local function safeDisconnect(connection)
    if connection and connection.Disconnect then
        connection:Disconnect()
    end
end

-- Function to manage connections
local function manageConnection(flag, varName, runServiceFunc)
    if flag then
        if not _G[varName] then
            -- Create the RunService connection if the flag is true and connection is not already created
            _G[varName] = RunService[runServiceFunc]:Connect(function()
                -- Your code for what the connection does
            end)
        end
    else
        -- Disconnect and clear the connection if the flag is false
        safeDisconnect(_G[varName])
        _G[varName] = nil
    end
end

-- Main loop running on Heartbeat (V2)
RunService.Heartbeat:Connect(function()
    manageConnection(visualize_Enabled, "visualizeranalys", "Heartbeat")
    manageConnection(auto_spam, "autospamanalys", "Heartbeat")
    manageConnection(aura_Enabled, "autoparryanalys", "Heartbeat")
end)

-- Cool Lib

local NothingLibrary = loadstring(game:HttpGetAsync('https://raw.githubusercontent.com/3345-c-a-t-s-u-s/NOTHING/main/source.lua'))();

local Notification = NothingLibrary.Notification();

local Windows = NothingLibrary.new({

	Title = "Vico - NeuX",

	Description = "Vico - Blade Ball - Test",

	Keybind = Enum.KeyCode.LeftControl,

	Logo = 'http://www.roblox.com/asset/?id=18898582662'

})



Notification.new({

	Description = 'Welcome Tester!',

	Title = "Weladalah üòπ",

	Duration = 4,

	Icon = "rbxassetid://7733993369",

})



local TabFrame = Windows:NewTab({

	Title = "Main",

	Description = "P/S/V",

	Icon = "rbxassetid://7733960981"

})



-- Bagian AUTO Section

local AutoSection = TabFrame:NewSection({

	Title = "AUTO",

	Icon = "rbxassetid://7743869054",

	Position = "Left"

})



AutoSection:NewToggle({

	Title = "Auto Parry",

	Default = false,

	Callback = function(state)

		aura_Enabled = state

	end,

})



AutoSection:NewToggle({

	Title = "Auto Spam",

	Default = false,

	Callback = function(state)

		auto_spam = state

	end,

})



AutoSection:NewToggle({

	Title = "Manual SPAM",

	Default = false,

	Callback = function(state)

		ManualSpam()

	end,

})



-- Bagian VISUAL Section

local VisualSection = TabFrame:NewSection({

	Title = "VISUAL",

	Icon = "rbxassetid://7743869054",

	Position = "Right"

})



VisualSection:NewToggle({

	Title = "Visualizer Range (Spam, Parry)",

	Default = false,

	Callback = function(state)

		visualize_Enabled = state

	end,

})



-- Bagian INFORMATION Section

local InfoSection = TabFrame:NewSection({

	Title = "INFORMATION",

	Icon = "rbxassetid://7733964719",

	Position = "Left"

})



InfoSection:NewTitle('SC INFO')

InfoSection:NewButton({

	Title = "Vico Info",

	Callback = function()

		print('Still Beta Test I know my script is bad')

	end,

})



-- Penanganan notifikasi jika Auto Parry/Spam aktif

local notificationShown = true  -- Flag untuk melacak jika notifikasi telah ditampilkan



-- Fungsi untuk cek secara berkala apakah ismyautoparryspamming aktif

local function checkSpamming()

	while true do  -- Loop infinite untuk cek kondisi

		if ismyautoparryspamming and not notificationShown then

			Notification.new({

				Title = "Detected Spam",

				Description = "Is Now Spamming", 

				Duration = 2

			})

			notificationShown = true  -- Set flag menjadi true setelah menampilkan notifikasi

		elseif not ismyautoparryspamming then

			notificationShown = false  -- Reset flag saat tidak ada spamming

		end

		wait(0.5)  -- Tunggu 0.5 detik sebelum cek lagi (atur sesuai kebutuhan)
	end
end

-- Menjalankan fungsi cek spamming dalam task terpisah
spawn(checkSpamming)
